//: [Previous](@previous)

/*:
 ## The "Crusty" Talk
![The Crusty Talk](POP-1.pdf)

 ## Classes are Awesome

 I would add Polymorphism to Dave's list.

 ![Classes are Awesome](ClassesAreAwesome.pdf)

 ## Types are Awesome

 Classes are a particular storage representation of Product types.  The manner in which a Product type is stored is orthogonal to it semantics as a Product type.

 Beef 0 - Traditional Classes Give Up:

 1. the isolation and atomicity of value semantics and
 1. the expressiveness of enums (Sum types) as objects.

 NB We can get some of this back using them as generic reference types.

 ![Types are Awesome](TypesAreAwesome.pdf)

 ## The 3 Beefs
![The Three Beefs](POP-2.pdf)

 ## Concurrency

 Actors don't do inheritance.
![The Crusty Talk](POP-3.pdf)

 ## Single Inheritance

 If you have to derive from someone else's class to get behavior, you have a problem.
![The Crusty Talk](POP-4.pdf)

 ## Lost Type Relationships

 Classes inherently can provide only coarse-grained type relationships
![The Crusty Talk](POP-5.pdf)

 ## The Tell-tale Sign of a Lost Type Relationship

 If you use `as!`, `as?`, `isKindOf:`, `isMemberOf:` you have encountered the inability of inheritance to model fine-grained relationships between types.

![The Crusty Talk](POP-6.pdf)

 ## Protocol Oriented Programming
![The Crusty Talk](POP-7.pdf)

 ## The Challenge: Prove It!
![The Crusty Talk](POP-8.pdf)

 ## Protocols have problems too

 The point about lost type relationships also applies to protocols.

![Swift Evolution Proposal 335](SE-335.png)

 ## The Tell-tale Sign: Protocol Edition
![Return Types in Combine](CombineReturnTypes.png)

 ## Demand only comes in More and All
![Demand](Demand.png)

*/

print("C'est finis.")

//: [Next](@next)
